#!/usr/bin/python

import smbus
import json
import struct
import sqlite3
import subprocess
import time


CONFIG_FILE = '/koruza/config/koruza.conf'


class Controller(object):
    # Device addresses on the I2C bus.
    SFP_ADDRESS_A = 0x50
    SFP_ADDRESS_B = 0x51
    MOTOR_ADDRESS = 0x04

    # Input commands.
    COMMANDS = [
        'motor_next_x',
        'motor_next_y',
        'motor_next_f',
        'motor_command',
        'motor_laser',
        'motor_speed',
        'motor_accel',
    ]

    def __init__(self):
        self.bus = smbus.SMBus(1)
        self.state = {
            'motor_next_x': 0,
            'motor_next_y': 0,
            'motor_next_f': 0,
            'motor_current_x': 0,
            'motor_current_y': 0,
            'motor_current_f': 0,
            'motor_max_x': 10000,
            'motor_max_y': 10000,
            'motor_max_f': 10000,
            'motor_status_x': 0,
            'motor_status_y': 0,
            'motor_status_f': 0,
            'motor_empty': 0,
            'motor_flash_status': 0,
            'motor_flash_write_count': 0,
            'motor_laser': 0,
            'motor_command': 0,
            'motor_speed': 0,
            'motor_accel': 0,
            'case_temperature_c': 0,
            'sfp_temperature_c': 0,
            'sfp_vcc_v': 0,
            'sfp_tx_bias_ma': 0,
            'sfp_tx_power_mw': 0,
            'sfp_rx_power_mw': 0,
            'remote_connected': 0,
        }
        self.present_i2c_sfp = False
        self.present_i2c_motor = False
        self.last_snapshot = 0

        # Load configuration.
        with open(CONFIG_FILE, 'r') as config_file:
            self.config = json.load(config_file)

    def initialize(self):
        # Check if all the required 1wire kernel modules are loaded and load them.
        loaded_modules = [x.split()[0] for x in open('/proc/modules').read().split('\n') if x]
        if 'w1_therm' not in loaded_modules or 'w1_gpio' not in loaded_modules:
            subprocess.call(["modprobe", "wire"])
            subprocess.call(["modprobe", "w1-gpio"])
            subprocess.call(["modprobe", "w1-therm"])

        # Check if SFP present at 0x50, should also check for 0x51 to make sure SFP is compatible and further tests.
        try:
            self.bus.write_byte(Controller.SFP_ADDRESS_B, 0)
            self.present_i2c_sfp = True
        except IOError:
            self.present_i2c_sfp = False

        # Check if motor driver present at 0x04.
        try:
            self.bus.write_byte(Controller.MOTOR_ADDRESS, 0)
            self.present_i2c_motor = True
        except IOError:
            self.present_i2c_motor = False

        print 'Motor driver present: %s' % self.present_i2c_motor
        print 'SFP present: %s' % self.present_i2c_sfp

        if self.present_i2c_sfp:
            # Read SFP information.
            sfp_info_byte = self.read_registers(Controller.SFP_ADDRESS_A, 0, 96)
            sfp_info_byte = "".join([chr(x) for x in sfp_info_byte])
            sfp_info = struct.unpack('=BBB8sBBBBBBBBB16sB3s16s4sBBBBHBB16s8sBBBB', sfp_info_byte)
            print 'SFP serial: %s' % sfp_info[26]
            print 'SFP model: %s' % sfp_info[16]

        # Initialize the database.
        self.create_tables()

    def _database(self):
        database = sqlite3.connect(self.config['database_path'])
        database.row_factory = sqlite3.Row

        return database

    def create_tables(self):
        columns = self.state.keys()
        database = self._database()

        # Create local and remote tables.
        for table in ('local', 'remote'):
            database.execute(
                'CREATE TABLE IF NOT EXISTS %(table)s (%(columns)s)' % {
                    'table': table,
                    'columns': ', '.join(columns),
                }
            )

        # Create historical data table.
        columns = ['timestamp'] + columns
        database.execute(
            'CREATE TABLE IF NOT EXISTS local_history (%(columns)s)' % {
                'table': table,
                'columns': ', '.join(columns),
            }
        )

    def load(self):
        database = self._database()
        cursor = database.execute('SELECT * FROM local')
        try:
            data = cursor.fetchone()
            for key in data.keys():
                if not key.startswith('motor_'):
                    continue

                self.state[key] = int(data[key])
        finally:
            cursor.close()
            database.close()

    def save(self):
        self.state['remote_connected'] = 1

        database = sqlite3.connect(self.config['database_path'])
        try:
            now = time.time()
            snapshot = [('timestamp', now)]
            for key, value in self.state.items():
                # Do not overwrite command fields.
                if key in Controller.COMMANDS:
                    continue

                database.execute(
                    'UPDATE local SET %(key)s = :value' % {
                        'key': key,
                    },
                    {'value': value},
                )
                snapshot.append((key, value))

            if now - self.last_snapshot >= self.config['snapshot_interval']:
                self.last_snapshot = now

                # Populate historic data with a new snapshot.
                database.execute(
                    'INSERT INTO local_history (%(columns)s) VALUES (%(placeholders)s)' % {
                        'columns': ', '.join([x[0] for x in snapshot]),
                        'placeholders': ', '.join(['?'] * len(snapshot)),
                    },
                    [x[1] for x in snapshot],
                )

                # Cleanup any old data.
                database.execute(
                    'DELETE FROM local_history WHERE timestamp < :window',
                    {'window': now - self.config['snapshot_window']},
                )

            database.commit()
        finally:
            database.close()

    def write_registers(self, address, offset, data):
        try:
            # Convert string to a list of bytes.
            converted = []
            for byte in data:
                converted.append(ord(byte))

            self.bus.write_block_data(address, offset, converted)
        except IOError:
            print 'WARNING: i2c motor driver write unavailable!'

    def read_registers(self, address, offset, length):
        try:
            self.bus.write_byte(address, offset)
            list = []
            for i in range(0, length):
                value = self.bus.read_byte(address)
                list.append(value)

            return list
        except IOError:
            print 'WARNING: i2c motor driver read unavailable!'

        return []

    def read_sensors(self):
        diag = self.read_registers(Controller.SFP_ADDRESS_B, 0, 256)
        # TODO: 1wire disabled for now, must auto-detect sensor path.
        #second_line = getSecondLine ()
        #temperature_case    = format ( float ( second_line . split ( "=" ) [ 1 ] . rstrip () ) / 1000, '4.10f' )

        def conv(list, i, div):
            a = float((list[i] << 8) + list[i + 1])
            return (a / div)

        self.state.update({
            'case_temperature_c': 0,
            'sfp_temperature_c': format(conv(diag, 96, 256), '4.10f'),
            'sfp_vcc_v': format(conv(diag, 98, 10000), '4.10f'),
            'sfp_tx_bias_ma': format(conv(diag, 100, 500), '5.10f'),
            'sfp_tx_power_mw': format(conv(diag, 102, 10000), '2.10f'),
            'sfp_rx_power_mw': format(conv(diag, 104, 10000), '.10f'),
        })

    def control_motors(self):
        # Sending is a separate step due to 32 byte buffer limit and due to only some bytes being writable
        # where the motors should move.
        self.write_registers(
            Controller.MOTOR_ADDRESS,
            0,
            struct.pack(
                '=lll',
                self.state['motor_next_x'],
                self.state['motor_next_y'],
                self.state['motor_next_f']
            )
        )
        # Commands and configs.
        self.write_registers(
            Controller.MOTOR_ADDRESS,
            30,
            struct.pack(
                '=BBHH',
                self.state['motor_command'],
                self.state['motor_laser'],
                self.state['motor_speed'],
                self.state['motor_accel']
            )
        )

        try:
            # Now read values back from the motor short delay advised.
            byte_data = self.read_registers(Controller.MOTOR_ADDRESS, 0, 36)
            byte_data = "".join([chr(x) for x in byte_data])
            data = struct.unpack('=llllllBBBBBBBBHH', byte_data)

            self.state.update({
                'motor_current_x': data[3],
                'motor_current_y': data[4],
                'motor_current_f': data[5],
                'motor_status_x': data[6],
                'motor_status_y': data[7],
                'motor_status_f': data[8],
                'motor_empty': data[9],
                'motor_flash_status': data[10],
                'motor_flash_write_count': data[11],
            })
        except TypeError:
            print 'WARNING: Failed to read motor data!'

    def start(self):
        while True:
            self.load()

            # Control the motors if driver is available.
            if self.present_i2c_motor:
                self.control_motors()

            # Read sensor data if driver is available.
            if self.present_i2c_sfp:
                self.read_sensors()

            # Persist data to the database.
            self.save()

# Initialize and start the controller.
controller = Controller()
controller.initialize()
controller.start()
