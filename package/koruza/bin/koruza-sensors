#!/usr/bin/env python
import smbus
import json
import struct
import subprocess
import nnpy
import select
import time


CONFIG_FILE = '/koruza/config/koruza.conf'


class IPC(object):
    # Information about the koruza-sensors process.
    TOPIC_PROCESS = 'process'
    # Status of the attached motors and SFP modules.
    TOPIC_STATUS = 'status'

    # Payload types.
    TYPE_EVENT = 'event'
    TYPE_MOTORS = 'motors'
    TYPE_SFP = 'sfp'
    TYPE_COMMAND = 'command'
    TYPE_COMMAND_REPLY = 'cmd_reply'
    TYPE_COMMAND_ERROR = 'cmd_error'
    TYPE_WATCHDOG = 'watchdog'

    # Event types.
    EVENT_STARTED = 'started'
    EVENT_ERROR = 'error'

    # Commands.
    COMMAND_GET_STATUS = 'get_status'
    COMMAND_MOTOR_MOVE = 'motor_move'
    COMMAND_MOTOR_CONFIG = 'motor_configure'

    # Error codes (reused from HTTP).
    ERROR_BAD_REQUEST = 400
    ERROR_INTERNAL_SERVER_ERROR = 500
    ERROR_NOT_IMPLEMENTED = 501

    def __init__(self, controller):
        self._controller = controller

        # Publish endpoint.
        self._publish = nnpy.Socket(nnpy.AF_SP, nnpy.PUB)
        self._publish.bind('ipc:///tmp/koruza-publish.ipc')

        # Command endpoint.
        self._command = nnpy.Socket(nnpy.AF_SP, nnpy.REP)
        self._command.bind('ipc:///tmp/koruza-command.ipc')

        self._poll = select.poll()
        self._poll.register(self._command.getsockopt(nnpy.SOL_SOCKET, nnpy.RCVFD), select.POLLIN)

    def poll(self):
        fds = self._poll.poll(10)
        if not fds:
            return

        try:
            data = json.loads(self._command.recv())
            if data.get('type', None) != IPC.TYPE_COMMAND:
                raise ValueError
            elif not data.get('command', None):
                raise ValueError
        except ValueError:
            return self.reply_error(IPC.ERROR_BAD_REQUEST, "Malformed request.")

        try:
            command = data['command']
            if command == IPC.COMMAND_GET_STATUS:
                # Returns general KORUZA controller status.
                return self.reply_ok(self._controller.get_status())
            elif command == IPC.COMMAND_MOTOR_MOVE:
                # Instructs the motors to move to a specific position.
                try:
                    self._controller.move_motors(
                        next_x=int(data['next_x']),
                        next_y=int(data['next_y']),
                        next_f=int(data['next_f']),
                    )
                    return self.reply_ok({'status': 'ok'})
                except ValueError:
                    return self.reply_error(IPC.ERROR_BAD_REQUEST, "Motor positions must be integers.")
                except KeyError, key:
                    return self.reply_error(IPC.ERROR_BAD_REQUEST, "Missing argument %s." % key)
            elif command == IPC.COMMAND_MOTOR_CONFIG:
                # Instructs the motors to reconfigure.
                try:
                    self._controller.configure_motors(
                        command=int(data['motor_command']),
                        laser=int(data['laser']),
                        speed=int(data['speed']),
                        accel=int(data['accel']),
                    )
                    return self.reply_ok({'status': 'ok'})
                except ValueError:
                    return self.reply_error(IPC.ERROR_BAD_REQUEST, "Motor configuration variables must be integers.")
                except KeyError, key:
                    return self.reply_error(IPC.ERROR_BAD_REQUEST, "Missing argument %s." % key)
            else:
                return self.reply_error(IPC.ERROR_NOT_IMPLEMENTED, "Command not implemented.")
        except:
            return self.reply_error(IPC.ERROR_INTERNAL_SERVER_ERROR, "Internal server error.")

    def reply(self, data):
        self._command.send(json.dumps(data))

    def reply_ok(self, data):
        msg = {
            'type': IPC.TYPE_COMMAND_REPLY,
        }
        msg.update(data)
        self.reply(msg)

    def reply_error(self, code, message):
        self.reply({
            'type': IPC.TYPE_COMMAND_ERROR,
            'code': code,
            'message': message,
        })

    def publish(self, topic, data):
        self._publish.send('%s\x00%s' % (topic, json.dumps(data)))

    def publish_event(self, event, **data):
        event = {
            'type': IPC.TYPE_EVENT,
            'event': event,
        }
        event.update(data)
        self.publish(IPC.TOPIC_PROCESS, event)

    def publish_error(self, message, **data):
        self.publish_event(IPC.EVENT_ERROR, message=message, **data)


class SFPNotFound(Exception):
    pass


class SFP(object):
    # Address offsets.
    ADDRESS_A = 0x00
    ADDRESS_B = 0x01

    def __init__(self, controller, address_base):
        self._controller = controller
        self.address_base = address_base

        # Ensure that there is actually a module at this address.
        try:
            self._write_byte(SFP.ADDRESS_A, 0x00)
        except IOError:
            raise SFPNotFound

        # Obtain SFP metadata.
        sfp_info_byte = self._read(SFP.ADDRESS_A, 0, 96)
        sfp_info_byte = "".join([chr(x) for x in sfp_info_byte])
        sfp_info = struct.unpack('=BBB8sBBBBBBBBB16sB3s16s4sBBBBHBB16s8sBBBB', sfp_info_byte)
        self.serial = sfp_info[26].strip()
        self.model = sfp_info[16].strip()

    def _write_byte(self, address_offset, data):
        self._controller.bus.write_byte(self.address_base + address_offset, data)

    def _read(self, address_offset, offset, length):
        return self._controller.read_registers(self.address_base + address_offset, offset, length)

    def read(self):
        diag = self._read(SFP.ADDRESS_B, 0, 256)

        def conv(list, i, div):
            a = float((list[i] << 8) + list[i + 1])
            return (a / div)

        return {
            'temperature_c': conv(diag, 96, 256),
            'vcc_v': conv(diag, 98, 10000),
            'tx_bias_ma': conv(diag, 100, 500),
            'tx_power_mw': conv(diag, 102, 10000),
            'rx_power_mw': conv(diag, 104, 10000),
        }

    def serialize(self):
        return {
            'address_base': self.address_base,
            'serial': self.serial,
            'model': self.model,
        }


class Controller(object):
    # Device addresses on the I2C bus.
    MOTOR_ADDRESS = 0x04

    def __init__(self):
        self.ipc = IPC(self)
        self.bus = smbus.SMBus(1)

        # Load configuration.
        with open(CONFIG_FILE, 'r') as config_file:
            self.config = json.load(config_file)

        # Check if all the required 1wire kernel modules are loaded and load them.
        loaded_modules = [x.split()[0] for x in open('/proc/modules').read().split('\n') if x]
        if 'w1_therm' not in loaded_modules or 'w1_gpio' not in loaded_modules:
            subprocess.call(["modprobe", "wire"])
            subprocess.call(["modprobe", "w1-gpio"])
            subprocess.call(["modprobe", "w1-therm"])

        # Check if SFP present at 0x50, should also check for 0x51 to make sure SFP is compatible and further tests.
        self.sfp = []
        # TODO: We currently only support a single SFP.
        try:
            self.sfp.append(SFP(self, address_base=0x50))
        except SFPNotFound:
            pass

        # Check if motor driver present at 0x04.
        try:
            self.bus.write_byte(Controller.MOTOR_ADDRESS, 0)
            self.motor = True
        except IOError:
            self.motor = False

        # Annouce that we have initialized.
        self.ipc.publish_event(
            IPC.EVENT_STARTED,
            features=self.get_status(),
        )

    def get_status(self):
        return {
            'motor': self.motor,
            'sfp': [sfp.serialize() for sfp in self.sfp],
        }

    def write_registers(self, address, offset, data):
        try:
            # Convert string to a list of bytes.
            converted = []
            for byte in data:
                converted.append(ord(byte))

            self.bus.write_block_data(address, offset, converted)
        except IOError:
            self.ipc.publish_error(
                "Failed to write to I2C bus.",
                address=address,
                offset=offset,
            )

    def read_registers(self, address, offset, length):
        try:
            self.bus.write_byte(address, offset)
            list = []
            for i in range(0, length):
                value = self.bus.read_byte(address)
                list.append(value)

            return list
        except IOError:
            self.ipc.publish_error(
                "Failed to read from I2C bus.",
                address=address,
                offset=offset,
                length=length,
            )

        return []

    def read_sfp(self):
        """
        Reads and publishes SFP module data.
        """

        # Read data from SFP modules.
        sfps = {}
        for sfp in self.sfp:
            sfps[sfp.serial] = sfp.read()

        # Publish SFP module state.
        self.ipc.publish(IPC.TOPIC_STATUS, {
            'type': IPC.TYPE_SFP,
            'sfp': sfps,
        })

    def read_motors(self):
        """
        Reads and publishes motor data.
        """

        if not self.motor:
            return

        try:
            byte_data = self.read_registers(Controller.MOTOR_ADDRESS, 0, 36)
            if not byte_data:
                return self.ipc.publish_error("Failed to read motor status.")

            byte_data = "".join([chr(x) for x in byte_data])
            data = struct.unpack('=llllllBBBBBBBBHH', byte_data)

            self.ipc.publish(IPC.TOPIC_STATUS, {
                'type': IPC.TYPE_MOTORS,
                'motor': {
                    'next_x': data[0],
                    'next_y': data[1],
                    'next_f': data[2],
                    'current_x': data[3],
                    'current_y': data[4],
                    'current_f': data[5],
                    'status_x': data[6],
                    'status_y': data[7],
                    'status_f': data[8],
                    'empty': data[9],
                    'flash_status': data[10],
                    'flash_write_count': data[11],
                    'command': data[12],
                    'laser': data[13],
                    'speed': data[14],
                    'accel': data[15],
                }
            })
        except TypeError:
            self.ipc.publish_error("Failed to read motor status.")

    def move_motors(self, next_x, next_y, next_f):
        self.write_registers(
            Controller.MOTOR_ADDRESS,
            0,
            struct.pack(
                '=lll',
                next_x,
                next_y,
                next_f,
            )
        )

    def configure_motors(self, command, laser, speed, accel):
        self.write_registers(
            Controller.MOTOR_ADDRESS,
            30,
            struct.pack(
                '=BBHH',
                command,
                laser,
                speed,
                accel,
            )
        )

    def start(self):
        """
        Starts the control loop.
        """

        last_watchdog_event = 0

        while True:
            self.ipc.poll()
            self.read_motors()
            self.read_sfp()

            # Emit a watchdog message every 30 seconds so that other components can check
            # if we are still alive.
            if time.time() - last_watchdog_event > 30:
                self.ipc.publish(IPC.TOPIC_PROCESS, {
                    'type': IPC.TYPE_WATCHDOG,
                    'time': time.time(),
                })
                last_watchdog_event = time.time()

# Initialize and start the controller.
controller = Controller()
controller.start()
