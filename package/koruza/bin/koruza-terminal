#!/usr/bin/python
import urwid
import time
import json
import sqlite3
import math

CONFIG_FILE = '/koruza/config/koruza.conf'
DATABASE_FILE = '/var/tmp/koruza/database.db'
UPDATE_INTERVAL = 0.2
NOTATION_WANING = 1
NOTATION_INFO = 0
NOTATION_CRITICAL = 2


class MotorNotMoving(Exception):
    pass


class UnitState(object):
    """
    Represents state of a KORUZA unit.
    """

    STATE = {
        'motor_next_x': {'type': int},
        'motor_next_y': {'type': int},
        'motor_next_f': {'type': int},
        'motor_current_x': {'type': int},
        'motor_current_y': {'type': int},
        'motor_current_f': {'type': int},
        'motor_max_x': {'type': int, 'default': 10000},
        'motor_max_y': {'type': int, 'default': 10000},
        'motor_max_f': {'type': int, 'default': 10000},
        'motor_status_x': {'type': int},
        'motor_status_y': {'type': int},
        'motor_status_f': {'type': int},
        'motor_speed': {'type': int},
        'motor_accel': {'type': int},
        'motor_command': {'type': int},
        'motor_flash_status': {'type': int},
        'motor_flash_write_count': {'type': int},
        'motor_laser': {'type': int},
        'remote_connected': {'type': int},
        'case_temperature_c': {'type': int},
        'sfp_temperature_c': {'type': float},
        'sfp_tx_bias_ma': {'type': float},
        'sfp_tx_power_mw': {'type': float},
        'sfp_rx_power_mw': {'type': float},
        'sfp_vcc_v': {'type': float},
    }

    def __init__(self, unit_id, database):
        self._unit_id = unit_id
        self._database = database
        self._state = {}
        for key, descriptor in UnitState.STATE.items():
            self._state[key] = descriptor['type'](descriptor.get('default', descriptor['type']()))

    def get_table_name(self):
        return self._unit_id

    def load(self):
        cursor = self._database.execute('SELECT * FROM %(table_name)s' % {'table_name': self.get_table_name()})
        try:
            data = cursor.fetchone()

            for key, descriptor in UnitState.STATE.items():
                if key in data.keys() and data[key]:
                    try:
                        self._state[key] = descriptor['type'](data[key])
                    except ValueError, error:
                        raise ValueError('Failed to decode state attribute \'%s\' (%s).' % (key, error.args[0]))
                else:
                    self._state[key] = descriptor['type'](descriptor.get('default', descriptor['type']()))
        finally:
            cursor.close()

    def update(self, key, value):
        if key not in UnitState.STATE:
            raise KeyError('Invalid unit state attribute \'%s\'.' % key)

        self._state[key] = UnitState.STATE[key]['type'](value)
        self._database.execute(
            'UPDATE %(table_name)s SET %(field)s = :value' % {
                'table_name': self.get_table_name(),
                'field': key,
            },
            {'value': self._state[key]},
        )
        self._database.commit()

    def move_motor(self, direction, steps):
        motor_next = 'motor_next_%s' % direction
        motor_max = 'motor_max_%s' % direction

        if steps > 0 and self._state[motor_next] >= self._state[motor_max]:
            raise MotorNotMoving('Reached maximum %s position, not moving.' % direction.upper())
        if steps < 0 and self._state[motor_next] <= 0:
            raise MotorNotMoving('Reached minimum %s position, not moving.' % direction.upper())

        self.update(
            motor_next,
            min(self._state[motor_next] + steps, self._state[motor_max]),
        )

        return self._state[motor_next]

    def move_motors(self, **motors):
        messages = []
        notation = NOTATION_INFO
        for direction, steps in motors.items():
            try:
                next_position = self.move_motor(direction, steps)
                messages.append('Moving on %s axis, next position: %s' % (direction.upper(), next_position))
            except MotorNotMoving, error:
                messages.append(error.args[0])
                notation = NOTATION_CRITICAL

        return ('; '.join(messages), notation)

    def __getattr__(self, key):
        try:
            return self._state[key]
        except KeyError:
            raise AttributeError(key)

    def __setattr__(self, key, value):
        if key.startswith('_'):
            return super(UnitState, self).__setattr__(key, value)

        self.update(key, value)


class Units(object):
    def __init__(self):
        # Initialize the database connection.
        self._database = sqlite3.connect(DATABASE_FILE)
        self._database.row_factory = sqlite3.Row

        # Initialize local and remote unit states.
        self.local = UnitState('local', self._database)
        self.remote = UnitState('remote', self._database)

    def load(self):
        self.local.load()
        self.remote.load()

# Load configuration file.
with open(CONFIG_FILE, 'r') as config_file:
    config = json.load(config_file)


def sin100(x):
    """.
    A sin function that returns values between 0 and 100 and repeats
    after x == 100.
    """

    return 50 + 50 * math.sin(x * math.pi / 50)


class TerminalModel:
    """
    A class responsible for storing the data that will be displayed
    on the graph, and keeping track of which mode is enabled.
    """

    data_max_value = 100

    def __init__(self):
        data = [
            ('Saw', range(0, 100, 2) * 2),
            ('Square', [0] * 30 + [100] * 30),
            ('Sine 1', [sin100(x) for x in range(100)]),
            ('Sine 2', [(sin100(x) + sin100(x * 2)) / 2. for x in range(100)]),
            ('Sine 3', [(sin100(x) + sin100(x * 3)) / 2. for x in range(100)]),
        ]
        self.modes = []
        self.data = {}
        for m, d in data:
            self.modes.append(m)
            self.data[m] = d

    def get_modes(self):
        return self.modes

    def set_mode(self, m):
        self.current_mode = m

    def get_data(self, offset, r):
        """
        Return the data in [offset:offset+r], the maximum value
        for items returned, and the offset at which the data
        repeats.
        """
        l = []
        d = self.data[self.current_mode]
        while r:
            offset = offset % len(d)
            segment = d[offset:offset + r]
            r -= len(segment)
            offset += len(segment)
            l += segment
        return l, self.data_max_value, len(d)


class TerminalView(urwid.WidgetWrap):
    """
    A class responsible for providing the application's interface and
    graph display.
    """
    palette = [
        ('body',         'black',      'light gray', 'standout'),
        ('header',       'white',      'dark red',   'bold'),
        ('screen edge',  'light blue', 'dark cyan'),
        ('main shadow',  'dark gray',  'black'),
        ('line',         'black',      'light gray', 'standout'),
        ('bg background','light gray', 'black'),
        ('bg 1',         'black',      'dark blue', 'standout'),
        ('bg 1 smooth',  'dark blue',  'black'),
        ('bg 2',         'black',      'dark cyan', 'standout'),
        ('bg 2 smooth',  'dark cyan',  'black'),
        ('button normal','light gray', 'dark blue', 'standout'),
        ('button select','white',      'dark green'),
        ('line',         'black',      'light gray', 'standout'),
        ('pg normal',    'white',      'black', 'standout'),
        ('pg complete',  'white',      'dark magenta'),
        ('pg smooth',     'dark magenta','black')
        ]

    graph_samples_per_bar = 50
    graph_num_bars = 100
    graph_offset_per_second = 5

    def __init__(self, controller):
        self.controller = controller
        self.started = True
        self.start_time = None
        self.offset = 0
        self.last_offset = None
        self.aiming = False
        urwid.WidgetWrap.__init__(self, self.main_window())

    def get_offset_now(self):
        if self.start_time is None:
            return 0
        if not self.started:
            return self.offset
        tdelta = time.time() - self.start_time
        return int(self.offset + (tdelta * self.graph_offset_per_second))

    def update_graph(self, force_update=False):
        o = self.get_offset_now()
        if o == self.last_offset and not force_update:
            return False
        self.last_offset = o
        gspb = self.graph_samples_per_bar
        r = gspb * self.graph_num_bars
        d, max_value, repeat = self.controller.get_data(o, r)
        l = []
        for n in range(self.graph_num_bars):
            value = sum(d[n * gspb:(n + 1) * gspb]) / gspb
            # toggle between two bar types
            if n & 1:
                l.append([0, value])
            else:
                l.append([value, 0])
        self.graph.set_data(l, max_value)

        # also update progress
        if (o // repeat) & 1:
            # show 100% for first half, 0 for second half
            if o % repeat > repeat // 2:
                prog = 0
            else:
                prog = 1
        else:
            prog = float(o % repeat) / repeat
        self.animate_progress.set_completion(prog)
        return True

    def update_message(self, message, notation=NOTATION_INFO, expire=1000):
        self.status_message.set_text(message)
        return True

    def update_status(self):
        local = self.controller.units.local

        self.local_motor_current_x_text.set_text('motor_current_x: %s' % local.motor_current_x)
        self.local_motor_next_x_text.set_text('motor_next_x: %s' % local.motor_next_x)
        self.local_motor_max_x_text.set_text('motor_max_x: %s' % local.motor_max_x)
        self.local_motor_status_x_text.set_text('motor_status_x: %s' % local.motor_status_x)
        self.local_motor_current_y_text.set_text('motor_current_y: %s' % local.motor_current_y)
        self.local_motor_next_y_text.set_text('motor_next_y: %s' % local.motor_next_y)
        self.local_motor_max_y_text.set_text('motor_max_y: %s' % local.motor_max_y)
        self.local_motor_status_y_text.set_text('motor_status_y: %s' % local.motor_status_y)
        self.local_motor_current_f_text.set_text('motor_current_f: %s' % local.motor_current_f)
        self.local_motor_next_f_text.set_text('motor_next_f: %s' % local.motor_next_f)
        self.local_motor_max_f_text.set_text('motor_max_f: %s' % local.motor_max_f)
        self.local_motor_status_f_text.set_text('motor_status_f: %s' % local.motor_status_f)
        self.local_motor_speed_text.set_text('motor_speed: %s' % local.motor_speed)
        self.local_motor_accel_text.set_text('motor_accel: %s' % local.motor_accel)
        self.local_motor_command_text.set_text('motor_command: %s' % local.motor_command)
        self.local_motor_flash_status_text.set_text('motor_flash_status: %s' % local.motor_flash_status)
        self.local_motor_flash_write_count_text.set_text('motor_flash_write_count: %s' % local.motor_flash_write_count)
        self.local_motor_laser_text.set_text('motor_laser: %s' % local.motor_laser)
        self.local_remote_connected_text.set_text('remote_connected: %s' % local.remote_connected)
        self.local_sfp_rx_power_mw_text.set_text('sfp_rx_power_mw: %s' % local.sfp_rx_power_mw)
        self.local_case_temperature_c_text.set_text('case_temperature_c: %s' % local.case_temperature_c)
        self.local_sfp_temperature_c_text.set_text('sfp_temperature_c: %s' % local.sfp_temperature_c)
        self.local_sfp_tx_bias_ma_text.set_text('sfp_tx_bias_ma: %s' % local.sfp_tx_bias_ma)
        self.local_sfp_tx_power_mw_text.set_text('sfp_tx_power_mw: %s' % local.sfp_tx_power_mw)
        self.local_sfp_vcc_v_text.set_text('sfp_vcc_v: %s' % local.sfp_vcc_v)

    def on_aim_button(self, button):
        """Toggle started state and button text."""
        if self.aiming: # stop animation
            button.set_label("Start Aiming")
            self.aiming = False
            self.update_message('Stopped Aiming !')
        else:
            button.set_label("Stop Aiming")
            self.aiming = True
            self.update_message('Started Aiming !')

    def on_key(self, key):
        if key == 'esc':
            self.exit_program(False)
        if self.aiming:
            self.update_message('Pressed Key:' + key)
            self.controller.aim(key)

    def on_animate_button(self, button):
        """Toggle started state and button text."""
        if self.started: # stop animation
            button.set_label("Start")
            self.offset = self.get_offset_now()
            self.started = False
            self.controller.stop_animation()
        else:
            button.set_label("Stop")
            self.started = True
            self.start_time = time.time()
            self.controller.animate_graph()

    def on_reset_button(self, w):
        self.offset = 0
        self.start_time = time.time()
        self.update_graph(True)

    def on_mode_button(self, button, state):
        """Notify the controller of a new mode setting."""
        if state:
            # The new mode is the label of the button
            self.controller.set_mode(button.get_label())
        self.last_offset = None

    def on_mode_change(self, m):
        """Handle external mode change by updating radio buttons."""
        for rb in self.mode_buttons:
            if rb.get_label() == m:
                rb.set_state(True, do_callback=False)
                break
        self.last_offset = None

    def on_unicode_checkbox(self, w, state):
        self.graph = self.bar_graph(state)
        self.graph_wrap._w = self.graph
        self.animate_progress = self.progress_bar(state)
        self.animate_progress_wrap._w = self.animate_progress
        self.update_graph(True)

    def main_shadow(self, w):
        """Wrap a shadow and background around widget w."""
        bg = urwid.AttrWrap(urwid.SolidFill(u"\u2592"), 'screen edge')
        shadow = urwid.AttrWrap(urwid.SolidFill(u" "), 'main shadow')

        bg = urwid.Overlay(
            shadow, bg,
            ('fixed left', 3), ('fixed right', 1),
            ('fixed top', 2), ('fixed bottom', 1)
        )
        w = urwid.Overlay(
            w, bg,
            ('fixed left', 2), ('fixed right', 3),
            ('fixed top', 1), ('fixed bottom', 2)
        )
        return w

    def bar_graph(self, smooth=False):
        satt = None
        if smooth:
            satt = {(1, 0): 'bg 1 smooth', (2, 0): 'bg 2 smooth'}
        w = urwid.BarGraph(['bg background', 'bg 1', 'bg 2'], satt=satt)
        return w

    def button(self, t, fn):
        w = urwid.Button(t, fn)
        w = urwid.AttrWrap(w, 'button normal', 'button select')
        return w

    def radio_button(self, g, l, fn):
        w = urwid.RadioButton(g, l, False, on_state_change=fn)
        w = urwid.AttrWrap(w, 'button normal', 'button select')
        return w

    def progress_bar(self, smooth=False):
        if smooth:
            return urwid.ProgressBar('pg normal', 'pg complete', 0, 1, 'pg smooth')
        else:
            return urwid.ProgressBar('pg normal', 'pg complete', 0, 1)

    def text_message(self, t=""):
        return urwid.Text(t)

    def exit_program(self, w):
        raise urwid.ExitMainLoop()

    def graph_controls(self):
        modes = self.controller.get_modes()
        # setup mode radio buttons
        self.mode_buttons = []
        group = []
        for m in modes:
            rb = self.radio_button(group, m, self.on_mode_button)
            self.mode_buttons.append(rb)
        # setup animate button
        self.animate_button = self.button("", self.on_animate_button)
        self.on_animate_button(self.animate_button)
        self.offset = 0
        self.animate_progress = self.progress_bar()
        animate_controls = urwid.GridFlow(
            [
                self.animate_button,
                self.button("Reset", self.on_reset_button),
            ],
            9, 2, 0, 'center'
        )

        if urwid.get_encoding_mode() == "utf8":
            unicode_checkbox = urwid.CheckBox(
                "Enable Unicode Graphics",
                on_state_change=self.on_unicode_checkbox
            )
        else:
            unicode_checkbox = urwid.Text("UTF-8 encoding not detected")

        self.status_message = self.text_message('Press Enter or Start aiming to aim')
        self.animate_progress_wrap = urwid.WidgetWrap(
            self.animate_progress)

        self.aim_button = self.button("Start Aiming", self.on_aim_button)
        #self.on_aim_button( self.aim_button )

        local = self.controller.units.local

        self.local_motor_current_x_text = self.text_message('motor_current_x: %s' % local.motor_current_x)
        self.local_motor_next_x_text = self.text_message('motor_next_x: %s' % local.motor_next_x)
        self.local_motor_max_x_text = self.text_message('motor_max_x: %s' % local.motor_max_x)
        self.local_motor_status_x_text = self.text_message('motor_status_x: %s' % local.motor_status_x)
        self.local_motor_current_y_text = self.text_message('motor_current_y: %s' % local.motor_current_y)
        self.local_motor_next_y_text = self.text_message('motor_next_y: %s' % local.motor_next_y)
        self.local_motor_max_y_text = self.text_message('motor_max_y: %s' % local.motor_max_y)
        self.local_motor_status_y_text = self.text_message('motor_status_y: %s' % local.motor_status_y)
        self.local_motor_current_f_text = self.text_message('motor_current_f: %s' % local.motor_current_f)
        self.local_motor_next_f_text = self.text_message('motor_next_f: %s' % local.motor_next_f)
        self.local_motor_max_f_text = self.text_message('motor_max_f: %s' % local.motor_max_f)
        self.local_motor_status_f_text = self.text_message('motor_status_f: %s' % local.motor_status_f)
        self.local_motor_speed_text = self.text_message('motor_speed: %s' % local.motor_speed)
        self.local_motor_accel_text = self.text_message('motor_accel: %s' % local.motor_accel)
        self.local_motor_command_text = self.text_message('motor_command: %s' % local.motor_command)
        self.local_motor_flash_status_text = self.text_message('motor_flash_status: %s' % local.motor_flash_status)
        self.local_motor_flash_write_count_text = self.text_message('motor_flash_write_count: %s' % local.motor_flash_write_count)
        self.local_motor_laser_text = self.text_message('motor_laser: %s' % local.motor_laser)
        self.local_remote_connected_text = self.text_message('remote_connected: %s' % local.remote_connected)
        self.local_sfp_rx_power_mw_text = self.text_message('sfp_rx_power_mw: %s' % local.sfp_rx_power_mw)
        self.local_case_temperature_c_text = self.text_message('case_temperature_c: %s' % local.case_temperature_c)
        self.local_sfp_temperature_c_text = self.text_message('sfp_temperature_c: %s' % local.sfp_temperature_c)
        self.local_sfp_tx_bias_ma_text = self.text_message('sfp_tx_bias_ma: %s' % local.sfp_tx_bias_ma)
        self.local_sfp_tx_power_mw_text = self.text_message('sfp_tx_power_mw: %s' % local.sfp_tx_power_mw)
        self.local_sfp_vcc_v_text = self.text_message('sfp_vcc_v: %s' % local.sfp_vcc_v)

        local_status = [
            urwid.Text("Local Status", align="center"),
            self.local_motor_current_x_text,
            self.local_motor_next_x_text,
            self.local_motor_max_x_text,
            self.local_motor_status_x_text,
            self.local_motor_current_y_text,
            self.local_motor_next_y_text,
            self.local_motor_max_y_text,
            self.local_motor_status_y_text,
            self.local_motor_current_f_text,
            self.local_motor_next_f_text,
            self.local_motor_max_f_text,
            self.local_motor_status_f_text,
            self.local_motor_speed_text,
            self.local_motor_accel_text,
            self.local_motor_command_text,
            self.local_motor_flash_status_text,
            self.local_motor_flash_write_count_text,
            self.local_motor_laser_text,
            self.local_remote_connected_text,
            self.local_sfp_rx_power_mw_text,
            self.local_case_temperature_c_text,
            self.local_sfp_temperature_c_text,
            self.local_sfp_tx_bias_ma_text,
            self.local_sfp_tx_power_mw_text,
            self.local_sfp_vcc_v_text
        ]

        l = [
            urwid.Text("Koruza Terminal", align="center"),
            urwid.LineBox(self.status_message),
            #urwid.Divider(),
            urwid.Text(
                [
                    "Q   W   E   <- LOCAL           REMOTE ->    T   Y   U\n"
                    "  \ | /        K  ::laser on/off::  L         \ | /  \n"
                    "A -[o]- D      V-F ::zoom focus:: O-P       G -[o]- J\n"
                    "  / | \        7-8 :motors speed: 9-0         / | \  \n"
                    "  Z   X   C      S  ::motors home::   H       B   N   M  "
                ],
                align='center'
            ),
            #urwid.Divider(),
            self.aim_button,
            #urwid.Divider(),
        ] + local_status
        w = urwid.ListBox(urwid.SimpleListWalker(l))
        return w

    def main_window(self):
        self.graph = self.bar_graph()
        self.graph_wrap = urwid.WidgetWrap(self.graph)
        vline = urwid.AttrWrap(urwid.SolidFill(u'\u2502'), 'line')
        c = self.graph_controls()
        w = urwid.Columns(
            [
                ('weight', 2, self.graph_wrap),
                ('fixed', 1, vline),
                c,
            ],
            dividechars=1,
            focus_column=2,
        )
        w = urwid.Padding(w, ('fixed left', 1), ('fixed right', 0))
        w = urwid.AttrWrap(w, 'body')
        w = urwid.LineBox(w)
        w = urwid.AttrWrap(w, 'line')
        w = self.main_shadow(w)
        return w


class TerminalController:
    """
    A class responsible for setting up the model and view and running
    the application.
    """

    def __init__(self):
        self.units = Units()
        self.steps_count = 1

        self.animate_alarm = None
        self.update_alarm = None
        self.model = TerminalModel()
        self.view = TerminalView(self)
        # use the first mode as the default
        mode = self.get_modes()[0]
        self.model.set_mode(mode)
        # update the view
        self.view.on_mode_change(mode)
        self.view.update_graph(True)

    def get_modes(self):
        """Allow our view access to the list of modes."""
        return self.model.get_modes()

    def set_mode(self, m):
        """Allow our view to set the mode."""
        rval = self.model.set_mode(m)
        self.view.update_graph(True)
        return rval

    def get_data(self, offset, range):
        """Provide data to our view for the graph."""
        return self.model.get_data(offset, range)

    def main(self):
        self.units.load()
        self.loop = urwid.MainLoop(self.view, self.view.palette, unhandled_input=self.view.on_key)
        self.refresh_data()
        self.loop.run()

    def stop_animation(self):
        """stop animating the graph"""
        if self.animate_alarm:
            self.loop.remove_alarm(self.animate_alarm)
        self.animate_alarm = None

    def refresh_data(self, loop=None, user_data=None):
        """update the graph and schedule the next update"""
        self.units.load()
        self.view.update_status()
        self.update_alarm = self.loop.set_alarm_in(UPDATE_INTERVAL, self.refresh_data)

    def aim(self, key):
        local = self.units.local
        remote = self.units.remote

        if key in ('w', 'up'):
            self.view.update_message(*local.move_motors(y=self.steps_count))
        elif key in ('x', 'down'):
            self.view.update_message(*local.move_motors(y=-self.steps_count))
        elif key in ('a', 'left'):
            self.view.update_message(*local.move_motors(x=-self.steps_count))
        elif key in ('d', 'right'):
            self.view.update_message(*local.move_motors(x=self.steps_count))
        elif key in ('q'):
            self.view.update_message(*local.move_motors(y=self.steps_count, x=-self.steps_count))
        elif key in ('e'):
            self.view.update_message(*local.move_motors(y=self.steps_count, x=self.steps_count))
        elif key in ('z'):
            self.view.update_message(*local.move_motors(y=-self.steps_count, x=-self.steps_count))
        elif key in ('c'):
            self.view.update_message(*local.move_motors(y=-self.steps_count, x=self.steps_count))
        elif key in ('v'):
            self.view.update_message(*local.move_motors(f=-self.steps_count))
        elif key in ('f'):
            self.view.update_message(*local.move_motors(f=self.steps_count))
        elif key in ('k'):
            if local.motor_laser == 0:
                local.motor_laser = 1
                self.view.update_message('Turning on local LASER!', NOTATION_CRITICAL)
            else:
                local.motor_laser = 0
                self.view.update_message('Turning off local LASER!', NOTATION_CRITICAL)
        elif key in ('s'):
            local.motor_command = 2
            self.view.update_message('Local koruza going home!', NOTATION_CRITICAL)
            time.sleep(1)
            local.motor_command = 0
        elif key in ('1'):
            self.steps_count = 1
            self.view.update_message('Setting steps count: %s' % self.steps_count, NOTATION_INFO)
        elif key in ('2'):
            self.steps_count = 50
            self.view.update_message('Setting steps count: %s' % self.steps_count, NOTATION_INFO)
        elif key in ('3'):
            self.steps_count = 200
            self.view.update_message('Setting steps count: %s' % self.steps_count, NOTATION_INFO)
        elif key in ('7'):
            if local.motor_speed != 50:
                local.motor_speed = 50
                self.view.update_message('Setting local motor speed: %s' % local.motor_speed, NOTATION_INFO)
        elif key in ('8'):
            if local.motor_speed != 200:
                local.motor_speed = 200
                self.view.update_message('Setting local motor speed: %s' % local.motor_speed, NOTATION_INFO)
        elif key in ('9'):
            if remote.motor_speed != 50:
                remote.motor_speed = 50
                self.view.update_message('Setting remote motor speed: %s' % remote.motor_speed, NOTATION_INFO)
        elif key in ('0'):
            if remote.motor_speed != 200:
                remote.motor_speed = 200
                self.view.update_message('Setting remote motor speed: %s' % remote.motor_speed, NOTATION_INFO)
        elif key in ('y'):
            self.view.update_message(*remote.move_motors(y=1))
        elif key in ('n'):
            self.view.update_message(*remote.move_motors(y=-1))
        elif key in ('g'):
            self.view.update_message(*remote.move_motors(x=-1))
        elif key in ('j'):
            self.view.update_message(*remote.move_motors(x=1))
        elif key in ('t'):
            self.view.update_message(*remote.move_motors(y=1, x=-1))
        elif key in ('u'):
            self.view.update_message(*remote.move_motors(y=1, x=1))
        elif key in ('b'):
            self.view.update_message(*remote.move_motors(y=-1, x=-1))
        elif key in ('m'):
            self.view.update_message(*remote.move_motors(y=-1, x=1))
        elif key in ('o'):
            self.view.update_message(*remote.move_motors(f=-1))
        elif key in ('p'):
            self.view.update_message(*remote.move_motors(f=1))
        elif key in ('l'):
            if remote.motor_laser == 0:
                remote.motor_laser = 1
                self.view.update_message('Turning on remote LASER!', NOTATION_CRITICAL)
            else:
                remote.motor_laser = 0
                self.view.update_message('Turning off remote LASER!', NOTATION_CRITICAL)
        elif key in ('h'):
            remote.motor_command = 2
            self.view.update_message('Remote koruza going home!', NOTATION_CRITICAL)
            time.sleep(1)
            remote.motor_command = 0
        elif key in ('enter'):
            self.view.button.set_label("Start Aiming")
            self.view.aiming = False
            return

TerminalController().main()
