#!/usr/bin/python

import urwid
import termios
import sys
import tty
import signal
import time
import json
import sqlite3
import threading


"""
TBD START
"""

import urwid

import math
import time

UPDATE_INTERVAL = 0.2
NOTATION_WANING = 1
NOTATION_INFO = 0
NOTATION_CRITICAL = 2

local_motor_next_x = 0
local_motor_next_y = 0
local_motor_next_f = 0
local_motor_current_x = 0
local_motor_current_y = 0
local_motor_current_f = 0
local_motor_max_x = 10000
local_motor_max_y = 10000
local_motor_max_f = 10000
local_motor_status_x = 0
local_motor_status_y = 0
local_motor_status_f = 0
local_motor_speed = 0
local_motor_accel = 0
local_motor_command = ""
local_motor_flash_status = 0
local_motor_flash_write_count = 0
local_motor_laser = 0
local_remote_connected = 0
local_sfp_rx_power_mw = 0
local_case_temperature_c = 0
local_sfp_temperature_c = 0
local_sfp_tx_bias_ma = 0
local_sfp_tx_power_mw = 0
local_sfp_vcc_v = 0

remote_motor_next_x = 0
remote_motor_next_y = 0
remote_motor_next_f = 0
remote_motor_current_x = 0
remote_motor_current_y = 0
remote_motor_current_f = 0
remote_motor_max_x = 10000
remote_motor_max_y = 10000
remote_motor_max_f = 10000
remote_motor_status_x = 0
remote_motor_status_y = 0
remote_motor_status_f = 0
remote_motor_speed = 0
remote_motor_accel = 0
remote_motor_command = ""
remote_motor_flash_status = 0
remote_motor_flash_write_count = 0
remote_motor_laser = 0
remote_remote_connected = 0
remote_sfp_rx_power_mw = 0
remote_case_temperature_c = 0
remote_sfp_temperature_c = 0
remote_sfp_tx_bias_ma = 0
remote_sfp_tx_power_mw = 0
remote_sfp_vcc_v = 0

killThread = False
steps_count = 1


def sin100( x ):
	""".
	A sin function that returns values between 0 and 100 and repeats
	after x == 100.
	"""
	return 50 + 50 * math.sin( x * math.pi / 50 )


"""
TBD END
"""

class ThreadLoop ( threading . Thread ):

	def run ( self ):
		global local_motor_next_x
		global local_motor_next_y
		global local_motor_next_f
		global local_motor_current_x
		global local_motor_current_y
		global local_motor_current_f
		global local_motor_max_x
		global local_motor_max_y
		global local_motor_max_f
		global local_motor_status_x
		global local_motor_status_y
		global local_motor_status_f
		global local_motor_speed
		global local_motor_accel
		global local_motor_command
		global local_motor_flash_status
		global local_motor_flash_write_count
		global local_motor_laser
		global killThread


		conn = sqlite3 . connect ( '/var/tmp/koruza/database.db' )
		cur = conn . cursor ()

		while True:
			if ( killThread == True ):
				break
#LOCAL
			cur . execute ( 'SELECT motor_accel from local' )
			db_local_motor_accel = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_command from local' )
			db_local_motor_command = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_current_f from local' )
			db_local_motor_current_f = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_current_x from local' )
			db_local_motor_current_x = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_current_y from local' )
			db_local_motor_current_y = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_flash_status from local' )
			db_local_motor_flash_status = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_flash_write_count from local' )
			db_local_motor_flash_write_count = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_laser from local' )
			db_local_motor_laser = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_max_f from local' )
			db_local_motor_max_f = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_max_x from local' )
			db_local_motor_max_x = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_max_y from local' )
			db_local_motor_max_y = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_next_f from local' )
			db_local_motor_next_f = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_next_x from local' )
			db_local_motor_next_x = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_next_y from local' )
			db_local_motor_next_y = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_speed from local' )
			db_local_motor_speed = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_status_f from local' )
			db_local_motor_status_f = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_status_x from local' )
			db_local_motor_status_x = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_status_y from local' )
			db_local_motor_status_y = cur . fetchone () [ 0 ]

#REMOTE
			cur . execute ( 'SELECT motor_accel from remote' )
			db_remote_motor_accel = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_command from remote' )
			db_remote_motor_command = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_current_f from remote' )
			db_remote_motor_current_f = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_current_x from remote' )
			db_remote_motor_current_x = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_current_y from remote' )
			db_remote_motor_current_y = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_flash_status from remote' )
			db_remote_motor_flash_status = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_flash_write_count from remote' )
			db_remote_motor_flash_write_count = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_laser from remote' )
			db_remote_motor_laser = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_max_f from remote' )
			db_remote_motor_max_f = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_max_x from remote' )
			db_remote_motor_max_x = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_max_y from remote' )
			db_remote_motor_max_y = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_next_f from remote' )
			db_remote_motor_next_f = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_next_x from remote' )
			db_remote_motor_next_x = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_next_y from remote' )
			db_remote_motor_next_y = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_speed from remote' )
			db_remote_motor_speed = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_status_f from remote' )
			db_remote_motor_status_f = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_status_x from remote' )
			db_remote_motor_status_x = cur . fetchone () [ 0 ]
			cur . execute ( 'SELECT motor_status_y from remote' )
			db_remote_motor_status_y = cur . fetchone () [ 0 ]

			change = False
#LOCAL
			if db_local_motor_next_x <> local_motor_next_x:
				change = True
				cur . execute ( 'UPDATE local SET motor_next_x = ?', (local_motor_next_x,) )
			if db_local_motor_next_y <> local_motor_next_y:
				change = True
				cur . execute ( 'UPDATE local SET motor_next_y = ?', (local_motor_next_y,) )
			if db_local_motor_next_f <> local_motor_next_f:
				change = True
				cur . execute ( 'UPDATE local SET motor_next_f = ?', (local_motor_next_f,) )
			if db_local_motor_current_x <> local_motor_current_x:
				change = True
				cur . execute ( 'UPDATE local SET motor_current_x = ?', (local_motor_current_x,) )
			if db_local_motor_current_y <> local_motor_current_y:
				change = True
				cur . execute ( 'UPDATE local SET motor_current_y = ?', (local_motor_current_y,) )
			if db_local_motor_current_f <> local_motor_current_f:
				change = True
				cur . execute ( 'UPDATE local SET motor_current_f = ?', (local_motor_current_f,) )
			if db_local_motor_max_x <> local_motor_max_x:
				change = True
				cur . execute ( 'UPDATE local SET motor_max_x = ?', (local_motor_max_x,) )
			if db_local_motor_max_y <> local_motor_max_y:
				change = True
				cur . execute ( 'UPDATE local SET motor_max_y = ?', (local_motor_max_y,) )
			if db_local_motor_max_f <> local_motor_max_f:
				change = True
				cur . execute ( 'UPDATE local SET motor_max_f = ?', (local_motor_max_f,) )
			if db_local_motor_status_x <> local_motor_status_x:
				change = True
				cur . execute ( 'UPDATE local SET motor_status_x = ?', (local_motor_status_x,) )
			if db_local_motor_status_y <> local_motor_status_y:
				change = True
				cur . execute ( 'UPDATE local SET motor_status_y = ?', (local_motor_status_y,) )
			if db_local_motor_status_f <> local_motor_status_f:
				change = True
				cur . execute ( 'UPDATE local SET motor_status_f = ?', (local_motor_status_f,) )
			if db_local_motor_speed <> local_motor_speed:
				change = True
				cur . execute ( 'UPDATE local SET motor_speed = ?', (local_motor_speed,) )
			if db_local_motor_accel <> local_motor_accel:
				change = True
				cur . execute ( 'UPDATE local SET motor_accel = ?', (local_motor_accel,) )
			if db_local_motor_command <> local_motor_command:
				change = True
				cur . execute ( 'UPDATE local SET motor_command = ?', (local_motor_command,) )
			if db_local_motor_flash_status <> local_motor_flash_status:
				change = True
				cur . execute ( 'UPDATE local SET motor_flash_status = ?', (local_motor_flash_status,) )
			if db_local_motor_flash_write_count <> local_motor_flash_write_count:
				change = True
				cur . execute ( 'UPDATE local SET motor_flash_write_count = ?', (local_motor_flash_write_count,) )
			if db_local_motor_laser <> local_motor_laser:
				change = True
				cur . execute ( 'UPDATE local SET motor_laser = ?', (local_motor_laser,) )

#REMOTE
			if db_remote_motor_next_x <> remote_motor_next_x:
				change = True
				cur . execute ( 'UPDATE remote SET motor_next_x = ?', (remote_motor_next_x,) )
			if db_remote_motor_next_y <> remote_motor_next_y:
				change = True
				cur . execute ( 'UPDATE remote SET motor_next_y = ?', (remote_motor_next_y,) )
			if db_remote_motor_next_f <> remote_motor_next_f:
				change = True
				cur . execute ( 'UPDATE remote SET motor_next_f = ?', (remote_motor_next_f,) )
			if db_remote_motor_current_x <> remote_motor_current_x:
				change = True
				cur . execute ( 'UPDATE remote SET motor_current_x = ?', (remote_motor_current_x,) )
			if db_remote_motor_current_y <> remote_motor_current_y:
				change = True
				cur . execute ( 'UPDATE remote SET motor_current_y = ?', (remote_motor_current_y,) )
			if db_remote_motor_current_f <> remote_motor_current_f:
				change = True
				cur . execute ( 'UPDATE remote SET motor_current_f = ?', (remote_motor_current_f,) )
			if db_remote_motor_max_x <> remote_motor_max_x:
				change = True
				cur . execute ( 'UPDATE remote SET motor_max_x = ?', (remote_motor_max_x,) )
			if db_remote_motor_max_y <> remote_motor_max_y:
				change = True
				cur . execute ( 'UPDATE remote SET motor_max_y = ?', (remote_motor_max_y,) )
			if db_remote_motor_max_f <> remote_motor_max_f:
				change = True
				cur . execute ( 'UPDATE remote SET motor_max_f = ?', (remote_motor_max_f,) )
			if db_remote_motor_status_x <> remote_motor_status_x:
				change = True
				cur . execute ( 'UPDATE remote SET motor_status_x = ?', (remote_motor_status_x,) )
			if db_remote_motor_status_y <> remote_motor_status_y:
				change = True
				cur . execute ( 'UPDATE remote SET motor_status_y = ?', (remote_motor_status_y,) )
			if db_remote_motor_status_f <> remote_motor_status_f:
				change = True
				cur . execute ( 'UPDATE remote SET motor_status_f = ?', (remote_motor_status_f,) )
			if db_remote_motor_speed <> remote_motor_speed:
				change = True
				cur . execute ( 'UPDATE remote SET motor_speed = ?', (remote_motor_speed,) )
			if db_remote_motor_accel <> remote_motor_accel:
				change = True
				cur . execute ( 'UPDATE remote SET motor_accel = ?', (remote_motor_accel,) )
			if db_remote_motor_command <> remote_motor_command:
				change = True
				cur . execute ( 'UPDATE remote SET motor_command = ?', (remote_motor_command,) )
			if db_remote_motor_flash_status <> remote_motor_flash_status:
				change = True
				cur . execute ( 'UPDATE remote SET motor_flash_status = ?', (remote_motor_flash_status,) )
			if db_remote_motor_flash_write_count <> remote_motor_flash_write_count:
				change = True
				cur . execute ( 'UPDATE remote SET motor_flash_write_count = ?', (remote_motor_flash_write_count,) )
			if db_remote_motor_laser <> remote_motor_laser:
				change = True
				cur . execute ( 'UPDATE remote SET motor_laser = ?', (remote_motor_laser,) )

			if change == True:
				conn . commit ()

			time . sleep ( 0.5 )
		conn . close ()

class TerminalModel:
	"""
	A class responsible for storing the data that will be displayed
	on the graph, and keeping track of which mode is enabled.
	"""

	data_max_value = 100

	def __init__(self):
		data = [ ('Saw', range(0,100,2)*2),
			('Square', [0]*30 + [100]*30),
			('Sine 1', [sin100(x) for x in range(100)] ),
			('Sine 2', [(sin100(x) + sin100(x*2))/2.
				for x in range(100)] ),
			('Sine 3', [(sin100(x) + sin100(x*3))/2.
				for x in range(100)] ),
			]
		self.modes = []
		self.data = {}
		for m, d in data:
			self.modes.append(m)
			self.data[m] = d

	def get_modes(self):
		return self.modes

	def set_mode(self, m):
		self.current_mode = m

	def get_data(self, offset, r):
		"""
		Return the data in [offset:offset+r], the maximum value
		for items returned, and the offset at which the data
		repeats.
		"""
		l = []
		d = self.data[self.current_mode]
		while r:
			offset = offset % len(d)
			segment = d[offset:offset+r]
			r -= len(segment)
			offset += len(segment)
			l += segment
		return l, self.data_max_value, len(d)


class TerminalView(urwid.WidgetWrap):
	"""
	A class responsible for providing the application's interface and
	graph display.
	"""
	palette = [
		('body',         'black',      'light gray', 'standout'),
		('header',       'white',      'dark red',   'bold'),
		('screen edge',  'light blue', 'dark cyan'),
		('main shadow',  'dark gray',  'black'),
		('line',         'black',      'light gray', 'standout'),
		('bg background','light gray', 'black'),
		('bg 1',         'black',      'dark blue', 'standout'),
		('bg 1 smooth',  'dark blue',  'black'),
		('bg 2',         'black',      'dark cyan', 'standout'),
		('bg 2 smooth',  'dark cyan',  'black'),
		('button normal','light gray', 'dark blue', 'standout'),
		('button select','white',      'dark green'),
		('line',         'black',      'light gray', 'standout'),
		('pg normal',    'white',      'black', 'standout'),
		('pg complete',  'white',      'dark magenta'),
		('pg smooth',     'dark magenta','black')
		]

	graph_samples_per_bar = 50
	graph_num_bars = 100
	graph_offset_per_second = 5

	def __init__(self, controller):
		self.controller = controller
		self.started = True
		self.start_time = None
		self.offset = 0
		self.last_offset = None
		self.aiming = False
		urwid.WidgetWrap.__init__(self, self.main_window())

	def get_offset_now(self):
		if self.start_time is None:
			return 0
		if not self.started:
			return self.offset
		tdelta = time.time() - self.start_time
		return int(self.offset + (tdelta*self.graph_offset_per_second))

	def update_graph(self, force_update=False):
		o = self.get_offset_now()
		if o == self.last_offset and not force_update:
			return False
		self.last_offset = o
		gspb = self.graph_samples_per_bar
		r = gspb * self.graph_num_bars
		d, max_value, repeat = self.controller.get_data( o, r )
		l = []
		for n in range(self.graph_num_bars):
			value = sum(d[n*gspb:(n+1)*gspb])/gspb
			# toggle between two bar types
			if n & 1:
				l.append([0,value])
			else:
				l.append([value,0])
		self.graph.set_data(l,max_value)

		# also update progress
		if (o//repeat)&1:
			# show 100% for first half, 0 for second half
			if o%repeat > repeat//2:
				prog = 0
			else:
				prog = 1
		else:
			prog = float(o%repeat) / repeat
		self.animate_progress.set_completion( prog )
		return True

	def update_message(self, message, notation=NOTATION_INFO, expire=1000):
		self.status_message.set_text(message)
		return True

	def update_status(self):
		self.local_motor_current_x_text.set_text('motor_current_x: '+ str(local_motor_current_x))
		self.local_motor_next_x_text.set_text('motor_next_x: '+ str(local_motor_next_x))
		self.local_motor_max_x_text.set_text('motor_max_x: '+ str(local_motor_max_x))
		self.local_motor_status_x_text.set_text('motor_status_x: '+ str(local_motor_status_x))
		self.local_motor_current_y_text.set_text('motor_current_y: '+ str(local_motor_current_y))
		self.local_motor_next_y_text.set_text('motor_next_y: '+ str(local_motor_next_y))
		self.local_motor_max_y_text.set_text('motor_max_y: '+ str(local_motor_max_y))
		self.local_motor_status_y_text.set_text('motor_status_y: '+ str(local_motor_status_y))
		self.local_motor_current_f_text.set_text('motor_current_f: '+ str(local_motor_current_f))
		self.local_motor_next_f_text.set_text('motor_next_f: '+ str(local_motor_next_f))
		self.local_motor_max_f_text.set_text('motor_max_f: '+ str(local_motor_max_f))
		self.local_motor_status_f_text.set_text('motor_status_f: '+ str(local_motor_status_f))
		self.local_motor_speed_text.set_text('motor_speed: '+ str(local_motor_speed))
		self.local_motor_accel_text.set_text('motor_accel: '+ str(local_motor_accel))
		self.local_motor_command_text.set_text('motor_command: '+ str(local_motor_command))
		self.local_motor_flash_status_text.set_text('motor_flash_status: '+ str(local_motor_flash_status))
		self.local_motor_flash_write_count_text.set_text('motor_flash_write_count: '+ str(local_motor_flash_write_count))
		self.local_motor_laser_text.set_text('motor_laser: '+ str(local_motor_laser))
		self.local_remote_connected_text.set_text('remote_connected: '+ str(local_remote_connected))
		self.local_sfp_rx_power_mw_text.set_text('sfp_rx_power_mw: '+ str(local_sfp_rx_power_mw))
		self.local_case_temperature_c_text.set_text('case_temperature_c: '+ str(local_case_temperature_c))
		self.local_sfp_temperature_c_text.set_text('sfp_temperature_c: '+ str(local_sfp_temperature_c))
		self.local_sfp_tx_bias_ma_text.set_text('sfp_tx_bias_ma: '+ str(local_sfp_tx_bias_ma))
		self.local_sfp_tx_power_mw_text.set_text('sfp_tx_power_mw: '+ str(local_sfp_tx_power_mw))
		self.local_sfp_vcc_v_text.set_text('sfp_vcc_v: '+ str(local_sfp_vcc_v))

	def on_aim_button(self, button):
		"""Toggle started state and button text."""
		if self.aiming: # stop animation
			button.set_label("Start Aiming")
			self.aiming = False
			self.update_message('Stopped Aiming !')
		else:
			button.set_label("Stop Aiming")
			self.aiming = True
			self.update_message('Started Aiming !')

	def on_key(self,key):
		if key == 'esc':
			self.exit_program(False)
		if self.aiming:
#            if key in ('q', 'Q'):
#                self.aiming = False
#            else:
			  self.update_message('Pressed Key:' + key)
			  self.controller.aim(key)

	def on_animate_button(self, button):
		"""Toggle started state and button text."""
		if self.started: # stop animation
			button.set_label("Start")
			self.offset = self.get_offset_now()
			self.started = False
			self.controller.stop_animation()
		else:
			button.set_label("Stop")
			self.started = True
			self.start_time = time.time()
			self.controller.animate_graph()

	def on_reset_button(self, w):
		self.offset = 0
		self.start_time = time.time()
		self.update_graph(True)

	def on_mode_button(self, button, state):
		"""Notify the controller of a new mode setting."""
		if state:
			# The new mode is the label of the button
			self.controller.set_mode( button.get_label() )
		self.last_offset = None

	def on_mode_change(self, m):
		"""Handle external mode change by updating radio buttons."""
		for rb in self.mode_buttons:
			if rb.get_label() == m:
				rb.set_state(True, do_callback=False)
				break
		self.last_offset = None

	def on_unicode_checkbox(self, w, state):
		self.graph = self.bar_graph( state )
		self.graph_wrap._w = self.graph
		self.animate_progress = self.progress_bar( state )
		self.animate_progress_wrap._w = self.animate_progress
		self.update_graph( True )

	def main_shadow(self, w):
		"""Wrap a shadow and background around widget w."""
		bg = urwid.AttrWrap(urwid.SolidFill(u"\u2592"), 'screen edge')
		shadow = urwid.AttrWrap(urwid.SolidFill(u" "), 'main shadow')

		bg = urwid.Overlay( shadow, bg,
			('fixed left', 3), ('fixed right', 1),
			('fixed top', 2), ('fixed bottom', 1))
		w = urwid.Overlay( w, bg,
			('fixed left', 2), ('fixed right', 3),
			('fixed top', 1), ('fixed bottom', 2))
		return w

	def bar_graph(self, smooth=False):
		satt = None
		if smooth:
			satt = {(1,0): 'bg 1 smooth', (2,0): 'bg 2 smooth'}
		w = urwid.BarGraph(['bg background','bg 1','bg 2'], satt=satt)
		return w

	def button(self, t, fn):
		w = urwid.Button(t, fn)
		w = urwid.AttrWrap(w, 'button normal', 'button select')
		return w

	def radio_button(self, g, l, fn):
		w = urwid.RadioButton(g, l, False, on_state_change=fn)
		w = urwid.AttrWrap(w, 'button normal', 'button select')
		return w

	def progress_bar(self, smooth=False):
		if smooth:
			return urwid.ProgressBar('pg normal', 'pg complete',
				0, 1, 'pg smooth')
		else:
			return urwid.ProgressBar('pg normal', 'pg complete',
				0, 1)

	def text_message(self, t=""):
		return urwid.Text(t)

	def exit_program(self, w):
		global killThread
		killThread = True
		raise urwid.ExitMainLoop()

	def graph_controls(self):
		modes = self.controller.get_modes()
		# setup mode radio buttons
		self.mode_buttons = []
		group = []
		for m in modes:
			rb = self.radio_button( group, m, self.on_mode_button )
			self.mode_buttons.append( rb )
		# setup animate button
		self.animate_button = self.button( "", self.on_animate_button)
		self.on_animate_button( self.animate_button )
		self.offset = 0
		self.animate_progress = self.progress_bar()
		animate_controls = urwid.GridFlow( [
			self.animate_button,
			self.button("Reset", self.on_reset_button),
			], 9, 2, 0, 'center')

		if urwid.get_encoding_mode() == "utf8":
			unicode_checkbox = urwid.CheckBox(
				"Enable Unicode Graphics",
				on_state_change=self.on_unicode_checkbox)
		else:
			unicode_checkbox = urwid.Text(
				"UTF-8 encoding not detected")
		self.status_message = self.text_message('Press Enter or Start aiming to aim')
		self.animate_progress_wrap = urwid.WidgetWrap(
			self.animate_progress)

		self.aim_button = self.button( "Start Aiming", self.on_aim_button)
		#self.on_aim_button( self.aim_button )

		self.local_motor_current_x_text = self.text_message('motor_current_x: '+ str(local_motor_current_x))
		self.local_motor_next_x_text = self.text_message('motor_next_x: '+ str(local_motor_next_x))
		self.local_motor_max_x_text = self.text_message('motor_max_x: '+ str(local_motor_max_x))
		self.local_motor_status_x_text = self.text_message('motor_status_x: '+ str(local_motor_status_x))
		self.local_motor_current_y_text = self.text_message('motor_current_y: '+ str(local_motor_current_y))
		self.local_motor_next_y_text = self.text_message('motor_next_y: '+ str(local_motor_next_y))
		self.local_motor_max_y_text = self.text_message('motor_max_y: '+ str(local_motor_max_y))
		self.local_motor_status_y_text = self.text_message('motor_status_y: '+ str(local_motor_status_y))
		self.local_motor_current_f_text = self.text_message('motor_current_f: '+ str(local_motor_current_f))
		self.local_motor_next_f_text = self.text_message('motor_next_f: '+ str(local_motor_next_f))
		self.local_motor_max_f_text = self.text_message('motor_max_f: '+ str(local_motor_max_f))
		self.local_motor_status_f_text = self.text_message('motor_status_f: '+ str(local_motor_status_f))
		self.local_motor_speed_text = self.text_message('motor_speed: '+ str(local_motor_speed))
		self.local_motor_accel_text = self.text_message('motor_accel: '+ str(local_motor_accel))
		self.local_motor_command_text = self.text_message('motor_command: '+ str(local_motor_command))
		self.local_motor_flash_status_text = self.text_message('motor_flash_status: '+ str(local_motor_flash_status))
		self.local_motor_flash_write_count_text = self.text_message('motor_flash_write_count: '+ str(local_motor_flash_write_count))
		self.local_motor_laser_text = self.text_message('motor_laser: '+ str(local_motor_laser))
		self.local_remote_connected_text = self.text_message('remote_connected: '+ str(local_remote_connected))
		self.local_sfp_rx_power_mw_text = self.text_message('sfp_rx_power_mw: '+ str(local_sfp_rx_power_mw))
		self.local_case_temperature_c_text = self.text_message('case_temperature_c: '+ str(local_case_temperature_c))
		self.local_sfp_temperature_c_text = self.text_message('sfp_temperature_c: '+ str(local_sfp_temperature_c))
		self.local_sfp_tx_bias_ma_text = self.text_message('sfp_tx_bias_ma: '+ str(local_sfp_tx_bias_ma))
		self.local_sfp_tx_power_mw_text = self.text_message('sfp_tx_power_mw: '+ str(local_sfp_tx_power_mw))
		self.local_sfp_vcc_v_text = self.text_message('sfp_vcc_v: '+ str(local_sfp_vcc_v))

		local_status = [ urwid.Text("Local Status",align="center"),
			self.local_motor_current_x_text,
			self.local_motor_next_x_text,
			self.local_motor_max_x_text,
			self.local_motor_status_x_text,
			self.local_motor_current_y_text,
			self.local_motor_next_y_text,
			self.local_motor_max_y_text,
			self.local_motor_status_y_text,
			self.local_motor_current_f_text,
			self.local_motor_next_f_text,
			self.local_motor_max_f_text,
			self.local_motor_status_f_text,
			self.local_motor_speed_text,
			self.local_motor_accel_text,
			self.local_motor_command_text,
			self.local_motor_flash_status_text,
			self.local_motor_flash_write_count_text,
			self.local_motor_laser_text,
			self.local_remote_connected_text,
			self.local_sfp_rx_power_mw_text,
			self.local_case_temperature_c_text,
			self.local_sfp_temperature_c_text,
			self.local_sfp_tx_bias_ma_text,
			self.local_sfp_tx_power_mw_text,
			self.local_sfp_vcc_v_text]

		l = [ urwid.Text("Koruza Terminal",align="center"),
			urwid.LineBox( self.status_message ),
			#urwid.Divider(),
			urwid.Text([
				"Q   W   E   <- LOCAL           REMOTE ->    T   Y   U\n"
				"  \ | /        K  ::laser on/off::  L         \ | /  \n"
				"A -[o]- D      V-F ::zoom focus:: O-P       G -[o]- J\n"
				"  / | \        7-8 :motors speed: 9-0         / | \  \n"
				"  Z   X   C      S  ::motors home::   H       B   N   M  "], align='center'),
			#urwid.Divider(),
			self.aim_button,
			#urwid.Divider(),
			] + local_status #+ [
			#urwid.Divider(),
			#self.button("Quit", self.exit_program ),
			#]
		w = urwid.ListBox(urwid.SimpleListWalker(l))
		return w

	def main_window(self):
		self.graph = self.bar_graph()
		self.graph_wrap = urwid.WidgetWrap( self.graph )
		vline = urwid.AttrWrap( urwid.SolidFill(u'\u2502'), 'line')
		c = self.graph_controls()
		w = urwid.Columns([('weight',2,self.graph_wrap),
			('fixed',1,vline), c],
			dividechars=1, focus_column=2)
		w = urwid.Padding(w,('fixed left',1),('fixed right',0))
		w = urwid.AttrWrap(w,'body')
		w = urwid.LineBox(w)
		w = urwid.AttrWrap(w,'line')
		w = self.main_shadow(w)
		return w

class TerminalController:
	"""
	A class responsible for setting up the model and view and running
	the application.
	"""

	

	def __init__(self):
		self.animate_alarm = None
		self.update_alarm = None
		self.model = TerminalModel()
		self.view = TerminalView( self )
		self.thread = ThreadLoop()
		# use the first mode as the default
		mode = self.get_modes()[0]
		self.model.set_mode( mode )
		# update the view
		self.view.on_mode_change( mode )
		self.view.update_graph(True)

	def get_modes(self):
		"""Allow our view access to the list of modes."""
		return self.model.get_modes()

	def set_mode(self, m):
		"""Allow our view to set the mode."""
		rval = self.model.set_mode( m )
		self.view.update_graph(True)
		return rval

	def get_data(self, offset, range):
		"""Provide data to our view for the graph."""
		return self.model.get_data( offset, range )

	def main(self):
		self.load_data()
		self.thread.start()
		self.loop = urwid.MainLoop(self.view, self.view.palette, unhandled_input=self.view.on_key)
		self.refresh_data()
		self.loop.run()

#	def animate_graph(self, loop=None, user_data=None):
#		self.view.update_graph()
#		self.animate_alarm = self.loop.set_alarm_in(
#			UPDATE_INTERVAL, self.animate_graph)

	def stop_animation(self):
		"""stop animating the graph"""
		if self.animate_alarm:
			self.loop.remove_alarm(self.animate_alarm)
		self.animate_alarm = None

	def refresh_data(self, loop=None, user_data=None):
		"""update the graph and schedule the next update"""
		self.load_data()
		self.view.update_status()
		self.update_alarm = self.loop.set_alarm_in(
			UPDATE_INTERVAL, self.refresh_data)

	def load_data(self):
		conn = sqlite3 . connect ( '/var/tmp/koruza/database.db' )
		cur = conn . cursor ()

		global local_motor_next_x
		global local_motor_next_y
		global local_motor_next_f
		global local_motor_current_x
		global local_motor_current_y
		global local_motor_current_f
		global local_motor_max_x
		global local_motor_max_y
		global local_motor_max_f
		global local_motor_status_x
		global local_motor_status_y
		global local_motor_status_f
		global local_motor_speed
		global local_motor_accel
		global local_motor_command
		global local_motor_flash_status
		global local_motor_flash_write_count
		global local_motor_laser
		global local_remote_connected
		global local_sfp_rx_power_mw
		global local_case_temperature_c
		global local_sfp_temperature_c
		global local_sfp_tx_bias_ma
		global local_sfp_tx_power_mw
		global local_sfp_vcc_v_text

		global remote_motor_next_x
		global remote_motor_next_y
		global remote_motor_next_f
		global remote_motor_current_x
		global remote_motor_current_y
		global remote_motor_current_f
		global remote_motor_max_x
		global remote_motor_max_y
		global remote_motor_max_f
		global remote_motor_status_x
		global remote_motor_status_y
		global remote_motor_status_f
		global remote_motor_speed
		global remote_motor_accel
		global remote_motor_command
		global remote_motor_flash_status
		global remote_motor_flash_write_count
		global remote_motor_laser
		global remote_remote_connected
		global remote_sfp_rx_power_mw
		global remote_case_temperature_c
		global remote_sfp_temperature_c
		global remote_sfp_tx_bias_ma
		global remote_sfp_tx_power_mw
		global remote_sfp_vcc_v_text

		cur . execute ( 'SELECT motor_accel from local' )
		local_motor_accel = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_command from local' )
		local_motor_command = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_current_f from local' )
		local_motor_current_f = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_current_x from local' )
		local_motor_current_x = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_current_y from local' )
		local_motor_current_y = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_flash_status from local' )
		local_motor_flash_status = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_flash_write_count from local' )
		local_motor_flash_write_count = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_laser from local' )
		local_motor_laser = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_max_f from local' )
		local_motor_max_f = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_max_x from local' )
		local_motor_max_x = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_max_y from local' )
		local_motor_max_y = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_next_f from local' )
		local_motor_next_f = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_next_x from local' )
		local_motor_next_x = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_next_y from local' )
		local_motor_next_y = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_speed from local' )
		local_motor_speed = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_status_f from local' )
		local_motor_status_f = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_status_x from local' )
		local_motor_status_x = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_status_y from local' )
		local_motor_status_y = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT remote_connected from local' )
		local_remote_connected = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT sfp_rx_power_mw from local' )
		local_sfp_rx_power_mw = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT case_temperature_c from local' )
		local_case_temperature_c = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT sfp_temperature_c from local' )
		local_sfp_temperature_c = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT sfp_tx_bias_ma from local' )
		local_sfp_tx_bias_ma = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT sfp_tx_power_mw from local' )
		local_sfp_tx_power_mw = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT sfp_vcc_v from local' )
		local_sfp_vcc_v = cur . fetchone () [ 0 ]

		cur . execute ( 'SELECT motor_accel from remote' )
		remote_motor_accel = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_command from remote' )
		remote_motor_command = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_current_f from remote' )
		remote_motor_current_f = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_current_x from remote' )
		remote_motor_current_x = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_current_y from remote' )
		remote_motor_current_y = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_flash_status from remote' )
		remote_motor_flash_status = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_flash_write_count from remote' )
		remote_motor_flash_write_count = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_laser from remote' )
		remote_motor_laser = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_max_f from remote' )
		remote_motor_max_f = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_max_x from remote' )
		remote_motor_max_x = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_max_y from remote' )
		remote_motor_max_y = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_next_f from remote' )
		remote_motor_next_f = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_next_x from remote' )
		remote_motor_next_x = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_next_y from remote' )
		remote_motor_next_y = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_speed from remote' )
		remote_motor_speed = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_status_f from remote' )
		remote_motor_status_f = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_status_x from remote' )
		remote_motor_status_x = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT motor_status_y from remote' )
		remote_motor_status_y = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT remote_connected from remote' )
		remote_remote_connected = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT sfp_rx_power_mw from remote' )
		remote_sfp_rx_power_mw = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT case_temperature_c from remote' )
		remote_case_temperature_c = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT sfp_temperature_c from remote' )
		remote_sfp_temperature_c = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT sfp_tx_bias_ma from remote' )
		remote_sfp_tx_bias_ma = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT sfp_tx_power_mw from remote' )
		remote_sfp_tx_power_mw = cur . fetchone () [ 0 ]
		cur . execute ( 'SELECT sfp_vcc_v from remote' )
		remote_sfp_vcc_v = cur . fetchone () [ 0 ]

	def save_data(self):
		data = {
			u"motor_next_x": self.local_motor_next_x,
			u"motor_next_y": self.local_motor_next_y,
			u"motor_next_f": self.local_motor_next_f,
			u"motor_current_x": self.local_motor_current_x,
			u"motor_current_y": self.local_motor_current_y,
			u"motor_current_f": self.local_motor_current_f,
			u"motor_max_x": self.local_motor_max_x,
			u"motor_max_y": self.local_motor_max_y,
			u"motor_max_f": self.local_motor_max_f,
			u"motor_status_x": self.local_motor_status_x,
			u"motor_status_y": self.local_motor_status_y,
			u"motor_status_f": self.local_motor_status_f,
			u"motor_speed": self.local_motor_speed,
			u"motor_accel": self.local_motor_accel,
			u"motor_command": self.local_motor_command,
			u"motor_flash_status": self.local_motor_flash_status,
			u"motor_flash_write_count": self.local_motor_flash_write_count,
			u"motor_laser": self.local_motor_laser
		}
		file = open ( '/var/tmp/koruza/input.json', 'w' )
		try:
			file.write ( json.dumps ( data, indent = 2, sort_keys = True ) )
		except:
			exit
		file.write ( "\n" )
		file.close ()

	def aim(self, key):
		#size = self.ui.get_cols_rows()
		#canvas = self.view.render(size, focus=1)
		#self.ui.draw_screen(size, canvas)
		#conn = sqlite3 . connect ( '/var/tmp/koruza/database.db' )
		#cur = conn . cursor ()
		save_data = False
		global steps_count

		global local_motor_next_x
		global local_motor_next_y
		global local_motor_next_f
		global local_motor_current_x
		global local_motor_current_y
		global local_motor_current_f
		global local_motor_max_x
		global local_motor_max_y
		global local_motor_max_f
		global local_motor_status_x
		global local_motor_status_y
		global local_motor_status_f
		global local_motor_speed
		global local_motor_accel
		global local_motor_command
		global local_motor_flash_status
		global local_motor_flash_write_count
		global local_motor_laser

		global remote_motor_next_x
		global remote_motor_next_y
		global remote_motor_next_f
		global remote_motor_current_x
		global remote_motor_current_y
		global remote_motor_current_f
		global remote_motor_max_x
		global remote_motor_max_y
		global remote_motor_max_f
		global remote_motor_status_x
		global remote_motor_status_y
		global remote_motor_status_f
		global remote_motor_speed
		global remote_motor_accel
		global remote_motor_command
		global remote_motor_flash_status
		global remote_motor_flash_write_count
		global remote_motor_laser
		if key in ('w', 'up'):
			if ( local_motor_next_y >= local_motor_max_y ):
				self.view.update_message('Reached maximum Y position, not moving up !',NOTATION_CRITICAL)
			else:
				local_motor_next_y += steps_count
				self.view.update_message('Moving up on Y axis, next position: ' + str( local_motor_next_y ),NOTATION_INFO)
				self.save_data()
		elif key in ('x', 'down'):
			if ( local_motor_next_y <= 0 ):
				self.view.update_message('Reached minimum Y position, not moving down !',NOTATION_CRITICAL)
			else:
				local_motor_next_y -= steps_count
				self.view.update_message('Moving down on Y axis, next position: ' + str( local_motor_next_y ),NOTATION_INFO)
				self.save_data()
		elif key in ('a', 'left'):
			if ( local_motor_next_x <= 0 ):
				self.view.update_message('Reached minimum X position, not moving left !',NOTATION_CRITICAL)
			else:
				local_motor_next_x -= steps_count
				self.view.update_message('Moving left on X axis, next position: ' + str( local_motor_next_x ),NOTATION_INFO)
				self.save_data()
		elif key in ('d', 'right'):
			if ( local_motor_next_x >= local_motor_max_x ):
				self.view.update_message('Reached maximum X position, not moving right !',NOTATION_CRITICAL)
			else:
				local_motor_next_x += steps_count
				self.view.update_message('Moving right on X axis, next position: ' + str( local_motor_next_x ),NOTATION_INFO)
				self.save_data()
		elif key in ('q'):
			if ( local_motor_next_y >= local_motor_max_y ):
				message_first = 'Reached maximum Y position, not moving up !'
				notation_first = NOTATION_CRITICAL
			else:
				local_motor_next_y += steps_count
				message_first = 'Moving up on Y axis, next position: ' + str( local_motor_next_y )
				notation_first = NOTATION_INFO
				save_data = True
			if ( local_motor_next_x <= 0 ):
				message_second = 'Reached minimum X position, not moving left !'
				notation_second = NOTATION_CRITICAL
			else:
				local_motor_next_x -= steps_count
				message_second = 'Moving left on X axis, next position: ' + str( local_motor_next_x )
				notation_second = NOTATION_INFO
				save_data = True
			if (notation_first > notation_second):
				final_notation = notation_first
			else:
				final_notation = notation_second
			self.view.update_message(message_first + ', and ' + message_second,final_notation)
			if ( save_data ):
				self.save_data()
			save_data = False
		elif key in ('e'):
			if ( local_motor_next_y >= local_motor_max_y ):
				message_first = 'Reached maximum Y position, not moving up !'
				notation_first = NOTATION_CRITICAL
			else:
				local_motor_next_y += steps_count
				message_first = 'Moving up on Y axis, next position: ' + str( local_motor_next_y )
				notation_first = NOTATION_INFO
				save_data = True
			if ( local_motor_next_x >= local_motor_max_x ):
				message_second = 'Reached maximum X position, not moving right !'
				notation_second = NOTATION_CRITICAL
			else:
				local_motor_next_x += steps_count
				message_second = 'Moving right on X axis, next position: ' + str( local_motor_next_x )
				notation_second = NOTATION_INFO
				save_data = True
			if (notation_first > notation_second):
				final_notation = notation_first
			else:
				final_notation = notation_second
			self.view.update_message(message_first + ', and ' + message_second,final_notation)
			if ( save_data ):
				self.save_data()
			save_data = False
		elif key in ('z'):
			if ( local_motor_next_y <= 0 ):
				message_first = 'Reached minimum Y position, not moving down !'
				notation_first = NOTATION_CRITICAL
			else:
				local_motor_next_y -= steps_count
				message_first = 'Moving down on Y axis, next position: ' + str( local_motor_next_y )
				notation_first = NOTATION_INFO
				save_data = True
			if ( local_motor_next_x <= 0 ):
				message_second = 'Reached minimum X position, not moving left !'
				notation_second = NOTATION_CRITICAL
			else:
				local_motor_next_x -= steps_count
				message_second = 'Moving left on X axis, next position: ' + str( local_motor_next_x )
				notation_second = NOTATION_INFO
				save_data = True
			if (notation_first > notation_second):
				final_notation = notation_first
			else:
				final_notation = notation_second
			self.view.update_message(message_first + ', and ' + message_second,final_notation)
			if ( save_data ):
				self.save_data()
			save_data = False
		elif key in ('c'):
			if ( local_motor_next_y <= 0 ):
				message_first = 'Reached minimum Y position, not moving down !'
				notation_first = NOTATION_CRITICAL
			else:
				local_motor_next_y -= steps_count
				message_first = 'Moving down on Y axis, next position: ' + str( local_motor_next_y )
				notation_first = NOTATION_INFO
				save_data = True
			if ( local_motor_next_x >= local_motor_max_x ):
				message_second = 'Reached maximum X position, not moving right !'
				notation_second = NOTATION_CRITICAL
			else:
				local_motor_next_x += steps_count
				message_second = 'Moving right on X axis, next position: ' + str( local_motor_next_x )
				notation_second = NOTATION_INFO
				save_data = True
			if (notation_first > notation_second):
				final_notation = notation_first
			else:
				final_notation = notation_second
			self.view.update_message(message_first + ', and ' + message_second,final_notation)
			if ( save_data ):
				self.save_data()
			save_data = False
		elif key in ('v'):
			if ( local_motor_next_f <= 0 ):
				self.view.update_message('Reached minimum F position, not zooming in !',NOTATION_CRITICAL)
			else:
				local_motor_next_f -= steps_count
				self.view.update_message('Zooming in on F axis, next position: ' + str( local_motor_next_f ),NOTATION_INFO)
				self.save_data()
		elif key in ('f'):
			if ( local_motor_next_f >= local_motor_max_f ):
				self.view.update_message('Reached maximum F position, not zooming out !',NOTATION_CRITICAL)
			else:
				local_motor_next_f += steps_count
				self.view.update_message('Zooming out F axis, next position: ' + str( local_motor_next_f ),NOTATION_INFO)
				self.save_data()
		elif key in ('k'):
			if ( local_motor_laser == 0 ):
				local_motor_laser = 1
				self.view.update_message('Turning on local LASER !',NOTATION_CRITICAL)
				self.save_data()
			else:
				local_motor_laser = 0
				self.view.update_message('Turning off local LASER !',NOTATION_CRITICAL)
				self.save_data()

		elif key in ('s'):
			local_motor_command = 2
			self.view.update_message ( 'Local koruza going home ! ', NOTATION_CRITICAL )
			self.save_data()
			time . sleep ( 1 )
			local_motor_command = 0
			self.save_data()

		elif key in ('1'):
			steps_count = 1
			self.view.update_message('Setting steps count: ' + str( steps_count ),NOTATION_INFO)
		elif key in ('2'):
			steps_count = 50
			self.view.update_message('Setting steps count: ' + str( steps_count ),NOTATION_INFO)
		elif key in ('3'):
			steps_count = 200
			self.view.update_message('Setting steps count: ' + str( steps_count ),NOTATION_INFO)
		elif key in ('7'):
			if ( local_motor_speed <> 50 ):
				local_motor_speed = 50
				self.view.update_message('Setting local motor speed: ' + str( local_motor_speed ),NOTATION_INFO)
				self.save_data()
		elif key in ('8'):
			if ( local_motor_speed <> 200 ):
				local_motor_speed = 200
				self.view.update_message('Setting local motor speed: ' + str( local_motor_speed ),NOTATION_INFO)
				self.save_data()
		elif key in ('9'):
			if ( remote_motor_speed <> 50 ):
				remote_motor_speed = 50
				self.view.update_message('Setting remote motor speed: ' + str( remote_motor_speed ),NOTATION_INFO)
				self.save_data()
		elif key in ('0'):
			if ( remote_motor_speed <> 200 ):
				remote_motor_speed = 200
				self.view.update_message('Setting remote motor speed: ' + str( remote_motor_speed ),NOTATION_INFO)
				self.save_data()

		elif key in ('y'):
			if ( remote_motor_next_y >= remote_motor_max_y ):
				self.view.update_message('Reached maximum Y position, not moving up !',NOTATION_CRITICAL)
			else:
				remote_motor_next_y += 1
				self.view.update_message('Moving up on Y axis, next position: ' + str( remote_motor_next_y ),NOTATION_INFO)
				self.save_data()
		elif key in ('n'):
			if ( remote_motor_next_y <= 0 ):
				self.view.update_message('Reached minimum Y position, not moving down !',NOTATION_CRITICAL)
			else:
				remote_motor_next_y -= 1
				self.view.update_message('Moving down on Y axis, next position: ' + str( remote_motor_next_y ),NOTATION_INFO)
				self.save_data()
		elif key in ('g'):
			if ( remote_motor_next_x <= 0 ):
				self.view.update_message('Reached minimum X position, not moving left !',NOTATION_CRITICAL)
			else:
				remote_motor_next_x -= 1
				self.view.update_message('Moving left on X axis, next position: ' + str( remote_motor_next_x ),NOTATION_INFO)
				self.save_data()
		elif key in ('j'):
			if ( remote_motor_next_x >= remote_motor_max_x ):
				self.view.update_message('Reached maximum X position, not moving right !',NOTATION_CRITICAL)
			else:
				remote_motor_next_x += 1
				self.view.update_message('Moving right on X axis, next position: ' + str( remote_motor_next_x ),NOTATION_INFO)
				self.save_data()
		elif key in ('t'):
			if ( remote_motor_next_y >= remote_motor_max_y ):
				message_first = 'Reached maximum Y position, not moving up !'
				notation_first = NOTATION_CRITICAL
			else:
				remote_motor_next_y += 1
				message_first = 'Moving up on Y axis, next position: ' + str( remote_motor_next_y )
				notation_first = NOTATION_INFO
				save_data = True
			if ( remote_motor_next_x <= 0 ):
				message_second = 'Reached minimum X position, not moving left !'
				notation_second = NOTATION_CRITICAL
			else:
				remote_motor_next_x -= 1
				message_second = 'Moving left on X axis, next position: ' + str( remote_motor_next_x )
				notation_second = NOTATION_INFO
				save_data = True
			if (notation_first > notation_second):
				final_notation = notation_first
			else:
				final_notation = notation_second
			self.view.update_message(message_first + ', and ' + message_second,final_notation)
			if ( save_data ):
				self.save_data()
			save_data = False
		elif key in ('u'):
			if ( remote_motor_next_y >= remote_motor_max_y ):
				message_first = 'Reached maximum Y position, not moving up !'
				notation_first = NOTATION_CRITICAL
			else:
				remote_motor_next_y += 1
				message_first = 'Moving up on Y axis, next position: ' + str( remote_motor_next_y )
				notation_first = NOTATION_INFO
				save_data = True
			if ( remote_motor_next_x >= remote_motor_max_x ):
				message_second = 'Reached maximum X position, not moving right !'
				notation_second = NOTATION_CRITICAL
			else:
				remote_motor_next_x += 1
				message_second = 'Moving right on X axis, next position: ' + str( remote_motor_next_x )
				notation_second = NOTATION_INFO
				save_data = True
			if (notation_first > notation_second):
				final_notation = notation_first
			else:
				final_notation = notation_second
			self.view.update_message(message_first + ', and ' + message_second,final_notation)
			if ( save_data ):
				self.save_data()
			save_data = False
		elif key in ('b'):
			if ( remote_motor_next_y <= 0 ):
				message_first = 'Reached minimum Y position, not moving down !'
				notation_first = NOTATION_CRITICAL
			else:
				remote_motor_next_y -= 1
				message_first = 'Moving down on Y axis, next position: ' + str( remote_motor_next_y )
				notation_first = NOTATION_INFO
				save_data = True
			if ( remote_motor_next_x <= 0 ):
				message_second = 'Reached minimum X position, not moving left !'
				notation_second = NOTATION_CRITICAL
			else:
				remote_motor_next_x -= 1
				message_second = 'Moving left on X axis, next position: ' + str( remote_motor_next_x )
				notation_second = NOTATION_INFO
				save_data = True
			if (notation_first > notation_second):
				final_notation = notation_first
			else:
				final_notation = notation_second
			self.view.update_message(message_first + ', and ' + message_second,final_notation)
			if ( save_data ):
				self.save_data()
			save_data = False
		elif key in ('m'):
			if ( remote_motor_next_y <= 0 ):
				message_first = 'Reached minimum Y position, not moving down !'
				notation_first = NOTATION_CRITICAL
			else:
				remote_motor_next_y -= 1
				message_first = 'Moving down on Y axis, next position: ' + str( remote_motor_next_y )
				notation_first = NOTATION_INFO
				save_data = True
			if ( remote_motor_next_x >= remote_motor_max_x ):
				message_second = 'Reached maximum X position, not moving right !'
				notation_second = NOTATION_CRITICAL
			else:
				remote_motor_next_x += 1
				message_second = 'Moving right on X axis, next position: ' + str( remote_motor_next_x )
				notation_second = NOTATION_INFO
				save_data = True
			if (notation_first > notation_second):
				final_notation = notation_first
			else:
				final_notation = notation_second
			self.view.update_message(message_first + ', and ' + message_second,final_notation)
			if ( save_data ):
				self.save_data()
			save_data = False
		elif key in ('o'):
			if ( remote_motor_next_f <= 0 ):
				self.view.update_message('Reached minimum F position, not zooming in !',NOTATION_CRITICAL)
			else:
				remote_motor_next_f -= 1
				self.view.update_message('Zooming in on F axis, next position: ' + str( remote_motor_next_f ),NOTATION_INFO)
				self.save_data()
		elif key in ('p'):
			if ( remote_motor_next_f >= remote_motor_max_f ):
				self.view.update_message('Reached maximum F position, not zooming out !',NOTATION_CRITICAL)
			else:
				remote_motor_next_f += 1
				self.view.update_message('Zooming out F axis, next position: ' + str( remote_motor_next_f ),NOTATION_INFO)
				self.save_data()
		elif key in ('l'):
			if ( remote_motor_laser == 0 ):
				remote_motor_laser = 1
				self.view.update_message('Turning on remote LASER !',NOTATION_CRITICAL)
				self.save_data()
			else:
				remote_motor_laser = 0
				self.view.update_message('Turning off remote LASER !',NOTATION_CRITICAL)
				self.save_data()
		elif key in ('h'):
			remote_motor_command = 2
			self.view.update_message ( 'Remote koruza going home ! ', NOTATION_CRITICAL )
			self.save_data()
			time . sleep ( 1 )
			remote_motor_command = 0
			self.save_data()

		elif key in ('enter'):
			self.view.button.set_label("Start Aiming")
			self.view.aiming = False
			return

TerminalController().main()

exit
